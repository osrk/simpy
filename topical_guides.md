# SimPy の基本

このガイドでは、SimPy の基本概念、つまりどのように機能するのかについて説明します。プロセス、イベント、環境とは何ですか?彼らに対して何ができるでしょうか？

## SimPy の仕組み

SimPy を分解すると、単なる非同期イベント ディスパッチャーです。イベントを生成し、特定のシミュレーション時間にスケジュールします。イベントは、優先度、シミュレーション時間、および増加するイベント ID によって並べ替えられます。イベントにはコールバックのリストもあり、イベントがトリガーされてイベント ループによって処理されるときに実行されます。イベントには戻り値がある場合もあります。

これに関係するコンポーネントは、環境、イベント、および作成するプロセス関数です。

プロセス関数
- シミュレーション モデルを実装する。つまり、プロセス関数はシミュレーションの動作を定義する。
- Event のインスタンスを生成するプレーンな Python ジェネレーター関数です。

環境
- これらのイベントをイベント リストに保存し、現在のシミュレーション時間を追跡する

動作
- プロセス関数がイベントを生成 (yield) すると、SimPy はそのプロセスをイベントのコールバックに追加し、イベントがトリガーされて処理されるまでプロセスを一時停止します。イベントを待機しているプロセスが再開されると、イベントの値も受け取ります。

これをすべて説明する非常に簡単な例を次に示します。コードは、内容を明確にするために必要以上に冗長になっています。このセクションの最後にそのコンパクト版があります。

```python
import simpy

def example(env):
    event = simpy.events.Timeout(env, delay=1, value=42)
    value = yield event
    print('now=%d, value=%d' % (env.now, value))

env = simpy.Environment()
example_gen = example(env)
p = simpy.events.Process(env, example_gen)

env.run()
now=1, value=42
```

上記の `example()` プロセス関数は、最初に Timeout イベントを作成します。環境、遅延、値を渡します。タイムアウトは、現在 + 遅延で自動的にスケジュールされます (そのため、環境が必要です)。他のイベントタイプは通常、現在のシミュレーション時間にスケジュールを設定します。

その後、プロセス関数はイベントを生成するため、一時停止されます。 SimPy がタイムアウトイベントを処理すると再開されます。プロセス関数はイベントの値 (42) も受け取ります。ただし、これはオプションであるため、値に興味がない場合、またはイベントに値がまったくない場合は、yield イベントでも問題ありませんでした。

最後に、プロセス関数は現在のシミュレーション時間 (環境の now 属性からアクセス可能) とタイムアウトの値を出力します。

必要なプロセス関数がすべて定義されている場合は、シミュレーション用にすべてのオブジェクトをインスタンス化できます。ほとんどの場合、Environment のインスタンスを作成することから始めます。これは、他のすべてを作成するときにそれを何度も渡す必要があるためです。

プロセス関数を開始するには、次の 2 つのことが必要です。

ジェネレーター オブジェクトを作成するには、プロセス関数を呼び出す必要があります。 (これでは、その関数のコードはまだ実行されません。これが当てはまる理由を理解するには、「Python yield キーワードの説明」を読んでください。)

次に、プロセスのインスタンスを作成し、環境とジェネレーター オブジェクトをそれに渡します。これにより、現在のシミュレーション時間に初期化イベントがスケジュールされ、プロセス関数の実行が開始されます。プロセス インスタンスは、プロセス関数が返されたときにトリガーされるイベントでもあります。これが便利な理由については、イベントのガイドで説明されています。

最後に、SimPy のイベント ループを開始できます。デフォルトでは、イベント リストにイベントがある限り実行されますが、until 引数を指定して、より早く停止させることもできます (シミュレーション コントロールを参照)。

次のガイドでは、環境と、その環境とイベントおよびプロセス機能との相互作用について詳しく説明します。

### “Best practice” version of the example above

```python
import simpy

def example(env):
    value = yield env.timeout(1, value=42)
    print('now=%d, value=%d' % (env.now, value))

env = simpy.Environment()
p = env.process(example(env))
env.run()
now=1, value=42
```

## Shared Resources
- Shared resource は、プロセス相互作用をモデル化するもう 1 つの方法です。
- これらは、プロセスがそれらを使用するためにキューに並ぶ輻輳ポイントを形成します。
- SimPy では、リソースの 3 つのカテゴリが定義されています。
  - Resouce – 限られた数のプロセスで一度に使用できるリソース (例: 限られた数の燃料ポンプを備えたガソリン スタンド)。
  - Container – 均質で未分化なバルクの生産と消費をモデル化するリソース。それは連続的 (水のように) または離散的 (リンゴのように) のいずれかです。
  - Store – Python オブジェクトの生成と消費を可能にするリソース。

### 資源の基本概念

すべてのリソースは同じ基本概念を共有しています。つまり、リソース自体は、通常は制限された容量を持つある種のコンテナです。プロセスは、リソースに何かを入れたり、何かを取り出したりしようとします。リソースがいっぱいまたは空の場合、キューに並んで待つ必要があります。

各リソースは大まかに次のようになります。

```
BaseResource(容量):
    put_queue
    get_queue

    put(): event
    get(): event
```

すべてのリソースには最大容量と 2 つのキューがあります。1 つはリソースに何かを入れたいプロセス用で、もう 1 つは何かを取り出したいプロセス用です。 put() メソッドと get() メソッドはどちらも、対応するアクションが成功したときにトリガーされるイベントを返します。

#### リソースと割り込み

プロセスが put イベントまたは get イベントの成功を待っている間、別のプロセスによって中断される可能性があります。割り込みをキャッチした後、プロセスには 2 つの可能性があります。

1. (再度イベントを発行することにより) リクエストを待ち続ける可能性があります。
2. リクエストの待機を停止する場合があります。この場合、イベントの cancel() メソッドを呼び出す必要があります。
これは忘れがちなので、すべてのリソース イベントは context manager です (詳細については、Python ドキュメントを参照してください)。

リソース システムはモジュール式で拡張可能です。たとえば、リソースは特殊なキューやイベント タイプを使用できます。これにより、ソートされたキューを使用したり、イベントに優先順位を追加したり、プリエンプションを提供したりすることができます。

### Resrouces
### contaners
### Stores

- Store を使用すると、(コンテナーに保存されるかなり抽象的な「量」とは対照的に) 具体的なオブジェクトの生産と消費をモデル化できます。 
- 1 つのストアに複数のタイプのオブジェクトを含めることもできます。
- Store のほかに、カスタム関数を使用してストアから取得するオブジェクトをフィルタリングできる FilterStore と、アイテムが優先順位でストアから取得される PriorityStore があります。

以下は、一般的なプロデューサー/コンシューマー シナリオをモデル化した簡単な例です。

```python
def producer(env, store):
    for i in range(100):
        yield env.timeout(2)
        yield store.put(f'spam {i}')
        print(f'Produced spam at', env.now)

def consumer(name, env, store):
    while True:
        yield env.timeout(1)
        print(name, 'requesting spam at', env.now)
        item = yield store.get()
        print(name, 'got', item, 'at', env.now)

env = simpy.Environment()
store = simpy.Store(env, capacity=2)

prod = env.process(producer(env, store))
consumers = [env.process(consumer(i, env, store)) for i in range(2)]

env.run(until=5)
0 requesting spam at 1
1 requesting spam at 1
Produced spam at 2
0 got spam 0 at 2
0 requesting spam at 3
Produced spam at 4
1 got spam 1 at 4
```

他のリソース タイプと同様に、容量属性を介してストアの容量を取得できます。属性 items は、ストアで現在入手可能なアイテムのリストを指します。 put キューと get キューには、put_queue 属性と get_queue 属性を介してアクセスできます。

(FilterStore, PriorityStore はまだ読んでない)